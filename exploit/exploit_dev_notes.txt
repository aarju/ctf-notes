jmp esp (DEP prevents this)

\xff, \xe4
buf + eip(pointer to jmp esp) + nop + shellcode

to find in gdb:
(gdb) find /b &system, +9999999, 0xff, 0xe4

Ret to libc

- You need a buffer big enough to overflow
- you need the address of system as seen by the binary
- you need the address of exit() as seen by the binary
- you need a memory address pointing to the string /bin/sh

gdb cheat sheet

(gdb) find &system, +9999999, "/bin/sh" 

gdb <program name> 
disassemble (disass) <function name>
info functions # run this at the start to show functions
info registers # (i r) # show registers

break <function name>
run "args" to execute the program

x/s <address> #examine something as a string
x/i <address> #examine as an instruction
x/d # decimal

If you want to view the stack in gdb:
x/24xw $esp #This will examine the value at esp and look at the next 24 hex words

#### to find the size of the stack
p/d ($ebp - $esp) / 4 # print in decimal the size of the stack

## to run python from the gdb command line
r $(python -c 'print "A"*24 +"B"')

####
# shellcode
####

To call execve in assembly set the registers as follows:
EAX = 0x0b
EBX = pointer to a string with the file name
ECX = pointer to the argv array
EDX = pointer to the options

then call 'int 0x80' to pass execution



